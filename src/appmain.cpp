#include <functional>
#include "appmain.h"
#include "osutils.h"
#include "polymesh.h"
#include "keycodes.h"
#include "timer.h"

CAppMain::CAppMain() :
        m_uiDisplay(*this)
{
}

CAppMain::~CAppMain()
{
    // delete any exisitng lightmaps generated by this tool
    for (CLightmapImg& lm : m_lightMapList)
    {
        lm.Free();
    }
    m_lightMapList.clear();
}

bool CAppMain::Init(int videoWidth, int videoHeight)
{
    // init video
    if (!m_display.Init(videoWidth, videoHeight))
    {
        OS::Abort("Display could not be initialised\n");
        return false;
    }

    // setup camera
    m_camera.SetPosition(glm::vec3(0, 0, 0));
    m_camera.SetViewportAspectRatio(static_cast<float>(videoWidth) / static_cast<float>(videoHeight));
    m_camera.SetFieldOfView(90);
    m_camera.SetNearAndFarPlanes(0.1f, 1500.0f);

    // set the active camera, used for default View and Projection matrix when rendering
    m_display.SetActiveCamera(&m_camera);

    // set viewport and camera dimensions
    OnScreenResize(videoWidth, videoHeight);

    // use same UI path to load a default mesh at startup
    if(!OnUIMeshLoad(OS::ResourcePath("meshes/default.rbmesh")))
    {
        return false;
    }

    return true;
}

int CAppMain::UpdateTick(float deltaTime)
{
    UpdateCameraInputs(deltaTime);
    return m_appDone;
}

void CAppMain::DrawTick(float deltaTime)
{
    m_lastDeltaTime = deltaTime;
    m_display.Draw(deltaTime);

    if (m_meshID != 0)
        m_display.RenderMeshID(m_meshID, m_camera);

    m_display.RenderAllTextObjects();
    m_uiDisplay.Draw();
}

void CAppMain::OnUIButtonPressed()
{

}

void CAppMain::UpdateCameraInputs(float deltaTime)
{
    UpdateTransformViaInputs(deltaTime);
}

void CAppMain::Shutdown()
{
    m_display.Shutdown();
}

void CAppMain::OnKeyDown(int keycode)
{
    m_inputs.Press(keycode);
}

void CAppMain::OnKeyUp(int keycode)
{
    m_inputs.Release(keycode);
}

void CAppMain::OnScreenResize(int width, int height)
{
    m_display.SetViewport(width, height);
    m_camera.SetViewport( static_cast<float>(width), static_cast<float>(height));
}

void CAppMain::OnMouseDown(int buttonId, double x, double y)
{
    if (m_uiDisplay.IsAnyItemActive())
        return;

    m_isMouseDown = true;
}

void CAppMain::OnMouseUp(int buttonId, double x, double y)
{
    if (m_uiDisplay.IsAnyItemActive())
        return;

    m_isMouseDown = false;
}

void CAppMain::OnMouseMove(float xrel, float yrel)
{
    if (m_uiDisplay.IsAnyItemActive())
        return;

    float delta = 10.0f * m_lastDeltaTime;

    if (m_isMouseDown)
    {
        m_camera.OffsetOrientation(0.0f, xrel * delta);
        m_camera.OffsetOrientation(yrel * delta, 0.0f);
    }
}

void CAppMain::OnMouseWheel(int y)
{
    if (m_uiDisplay.IsAnyItemActive())
        return;

    float movementDelta = 500.0f * m_lastDeltaTime;
    if (y == -1)
    {
        movementDelta = -movementDelta;
    }
    m_camera.OffsetPosition(movementDelta * m_camera.ForwardVector());
}

uint32_t CAppMain::UploadNewMesh(CPolyMesh& polyMesh, std::vector<CLightmapImg>& lightmaps)
{
    // remove if loaded already
    if (m_meshID != 0)
    {
        m_display.DeleteMesh(m_meshID);
        m_meshID = 0;
    }

    // load any current lightmaps in the file (if any)
    polyMesh.LoadLightmaps(m_display.GetMaterialMgr(), lightmaps);
    //mesh.LoadMaterials(m_display.GetMaterialMgr());

    // add this to the renderer
    m_meshID = m_display.AddMesh(m_polyMesh);
    return m_meshID;
}

void CAppMain::UpdateTransformViaInputs(float deltaTime)
{
    float moveSpeed = deltaTime * 250.0f; //250 units per second

    using namespace NKeyboardKeys;

    if (m_inputs.IsPressed(KB_KEY_W))
    {
        m_camera.OffsetPosition(moveSpeed * m_camera.ForwardVector());
        //transform.OffsetPosition(moveSpeed * transform.ForwardVector());
    }

    if (m_inputs.IsPressed(KB_KEY_S))
    {
        m_camera.OffsetPosition(moveSpeed * -m_camera.ForwardVector());
        //transform.OffsetPosition(moveSpeed * -transform.ForwardVector());
    }

    if (m_inputs.IsPressed(KB_KEY_A))
    {
        m_camera.OffsetPosition(moveSpeed * -m_camera.RightVector());
        //transform.OffsetPosition(moveSpeed * -transform.RightVector());
    }

    if (m_inputs.IsPressed(KB_KEY_D))
    {
        m_camera.OffsetPosition(moveSpeed * m_camera.RightVector());
        //transform.OffsetPosition(moveSpeed * transform.RightVector());
    }

    if (m_inputs.IsPressed(KB_KEY_X))
    {
        m_camera.OffsetPosition(moveSpeed * glm::vec3(0, 1, 0));
        //transform.OffsetPosition(moveSpeed * glm::vec3(0, 1, 0));
    }

    if (m_inputs.IsPressed(KB_KEY_LEFT))
    {
        m_camera.OffsetOrientation(0.0f, -70.0f * deltaTime);
        //transform.OffsetOrientation(0.0f, -70.0f * deltaTime);
    }

    if (m_inputs.IsPressed(KB_KEY_RIGHT))
    {
        m_camera.OffsetOrientation(0.0f, 70.0f * deltaTime);
        //transform.OffsetOrientation(0.0f, 70.0f * deltaTime);
    }

    if (m_inputs.IsPressed(KB_KEY_SPACE))
    {
        m_camera.OffsetPosition(moveSpeed * m_camera.UpVector());
        //transform.OffsetPosition(moveSpeed * transform.UpVector());
    }

    if (m_inputs.IsPressed(KB_KEY_Z))
    {
        m_camera.OffsetPosition(moveSpeed * -m_camera.UpVector());
        //transform.OffsetPosition(moveSpeed * -transform.UpVector());
    }
}

bool CAppMain::GenerateLightmaps(NRadeLamp::lmOptions_t lampOptions, std::vector<CLight> lights)
{
    std::string outFile(OS::ResourcePath("meshes/default.rbmesh"));

    // scale light colour values to RGB 0-255 instead of 0-1
    for (auto& light : lights)
    {
        for (float& i : light.color)
            i = std::min<float>(i * 255, 255);
    }

    // delete any exisitng lightmaps generated by this tool
    for (CLightmapImg& lm : m_lightMapList)
    {
        lm.Free();
    }
    m_lightMapList.clear();

    CLightmapGen lmGen;

    OS::Log("generating lightmap data..\n");
    CTimer timer;

    lmGen.RegisterCallback(
            [this](int pctComplete)
            {
                m_uiDisplay.SetPercentComplete(pctComplete, false);
            });

    lmGen.GenerateLightmaps(lampOptions, m_polyMesh.GetPolyListRef(), lights, &m_lightMapList);

    float elapsedTime = timer.ElapsedTime();
    OS::Log("lightmap generation took %.2f seconds\n", elapsedTime);

    // notify of completion (mesh is now written to file)
    m_uiDisplay.SetPercentComplete(100, true);
    return true;
}

bool CAppMain::OnUIMeshLoad(const std::string& filename)
{
    CMeshFile tmpMesh;
    if(tmpMesh.LoadFromFile(filename))
    {
        std::vector<CPoly3D> polyList;
        tmpMesh.GetAsPolyList(polyList);
        m_polyMesh.Clear();
        m_polyMesh.AddPolyList(polyList);

        // delete any existing lightmaps generated by this tool
        for (CLightmapImg& lm : m_lightMapList)
        {
            lm.Free();
        }
        m_lightMapList.clear();

        tmpMesh.GetLightMaps(m_lightMapList);
        m_polyMesh.LoadLightmaps(m_display.GetMaterialMgr(), m_lightMapList);

        m_meshID = UploadNewMesh(m_polyMesh, m_lightMapList);
//        typedef struct
//        {
//            char name[MATERIAL_NAME_LEN];
//            float pos[3];
//            float dir[3];
//            float radius;
//            float brightness;
//            float color[3];
//        } SLight;
        // import mesh lights
        std::vector<NMeshFile::SLight>& meshLights = tmpMesh.GetLightsRef();
        for(auto& light : meshLights)
        {
            CLight newLight{};
            newLight.name = std::string(light.name);
            newLight.pos = CPoint3D(light.pos);
            newLight.orientation = CPoint3D(light.dir);
            newLight.brightness = light.brightness;
            newLight.radius = light.radius;
            newLight.color[0] = light.color[0];
            newLight.color[1] = light.color[1];
            newLight.color[2] = light.color[2];
            AddLight(newLight);
        }

        return m_meshID>0;
    }
    else
    {
        OS::Log("Cant find mesh %s\n", filename.c_str());
        return false;
    }
}

void CAppMain::OnUILightmapsComplete()
{
    // m_lightmaps is now ready to use
    m_polyMesh.ClearLightmaps();
    UploadNewMesh(m_polyMesh, m_lightMapList);
}

bool CAppMain::OnUIMeshSave(const std::string& filename)
{
    OS::Log("storing compressed lightmap data in meshfile..\n");
    CMeshFile outputMeshFile(m_polyMesh.GetPolyListRef());

    for (CLightmapImg& lm : m_lightMapList)
    {
        // add these in the same order as generated so indexes match up
        outputMeshFile.AddLightmapData(lm.m_width, lm.m_height, lm.m_data, lm.m_width * lm.m_height * 4);
    }

    for(auto& light : m_lights)
    {
        outputMeshFile.AddLight(light);
    }

    if(!outputMeshFile.WriteToFile(filename))
    {
        OS::Log("Failed to save %s\n", filename.c_str());
        return false;
    }
    return true;
}

std::vector<CLight>& CAppMain::GetLightsRef()
{
    return m_lights;
}

bool CAppMain::RemoveLight(int index)
{
    m_lights.at(index).label->Reset();
    delete m_lights.at(index).label;
    m_lights.erase(m_lights.begin() + index);
    return true;
}

bool CAppMain::AddLight(CLight& newLight)
{
    CTextMesh *newLabel = new CTextMesh();
    if(!newLabel->Init(newLight.name, &m_display, &m_camera, newLight.pos, 4, "system/font"))
    {
        return false;
    }

    newLabel->SetText(newLight.name);
    newLight.label = newLabel;
    m_lights.emplace_back(newLight);
    return true;
}

bool CAppMain::ChangeLightPos(CLight& light, CPoint3D& pos)
{
    light.pos = pos;
    if(light.label)
    {
        light.label->SetPos(pos);
    }
    return true;
}
