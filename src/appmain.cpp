#include <functional>
#include "appmain.h"
#include "osutils.h"
#include "polymesh.h"
#include "keycodes.h"
#include "timer.h"

CAppMain::CAppMain() :
        m_uiDisplay(*this)
{
}

CAppMain::~CAppMain()
{
    // delete any exisitng lightmaps generated by this tool
    for (CLightmapImg& lm : m_lightMapList)
    {
        lm.Free();
    }
    m_lightMapList.clear();
}

bool CAppMain::Init(int videoWidth, int videoHeight)
{
    // init video
    if (!m_display.Init(videoWidth, videoHeight))
    {
        OS::Abort("Display could not be initialised\n");
        return false;
    }

    // setup camera
    m_camera.SetPosition(glm::vec3(0, 0, 0));
    m_camera.SetViewportAspectRatio(static_cast<float>(videoWidth) / static_cast<float>(videoHeight));
    m_camera.SetFieldOfView(90);
    m_camera.SetNearAndFarPlanes(0.1f, 1500.0f);

    // set the active camera, used for default View and Projection matrix when rendering
    m_display.SetActiveCamera(&m_camera);

    // set viewport and camera dimensions
    OnScreenResize(videoWidth, videoHeight);

    // use same UI path to load a default mesh at startup
    if(!OnUIMeshLoad(OS::ResourcePath("meshes/default.rbmesh")))
    {
        return false;
    }

    if(!m_txtCamPos.Init(&m_display, &m_camera, CPoint3D(0, 0, 0), 2, "system/font"))
    {
        return false;
    }

    m_txtCamPos.SetText("0, 0, 0");

    return true;
}

int CAppMain::UpdateTick(float deltaTime)
{
    UpdateCameraInputs(deltaTime);
    return m_appDone;
}

void CAppMain::DrawTick(float deltaTime)
{
    m_lastDeltaTime = deltaTime;
    m_display.Draw(deltaTime);

    if (m_meshID != 0)
        m_display.RenderMeshID(m_meshID, m_camera);

    m_display.RenderAllTextObjects();
    m_uiDisplay.Draw();
}

void CAppMain::OnUIButtonPressed()
{

}

void CAppMain::UpdateCameraInputs(float deltaTime)
{
    UpdateTransformViaInputs(deltaTime);
}

void CAppMain::Shutdown()
{
    m_display.Shutdown();
}

void CAppMain::OnKeyDown(int keycode)
{
    m_inputs.Press(keycode);
}

void CAppMain::OnKeyUp(int keycode)
{
    m_inputs.Release(keycode);
}

void CAppMain::OnScreenResize(int width, int height)
{
    m_display.SetViewport(width, height);
    m_camera.SetViewport(width, height);
}

void CAppMain::OnMouseDown(int buttonId, double x, double y)
{
    if (m_uiDisplay.IsAnyItemActive())
        return;

    m_isMouseDown = true;
}

void CAppMain::OnMouseUp(int buttonId, double x, double y)
{
    if (m_uiDisplay.IsAnyItemActive())
        return;

    m_isMouseDown = false;
}

void CAppMain::OnMouseMove(double xrel, double yrel)
{
    if (m_uiDisplay.IsAnyItemActive())
        return;

    float delta = 10.0f * m_lastDeltaTime;

    if (m_isMouseDown)
    {
        m_camera.OffsetOrientation(0.0f, xrel * delta);
        m_camera.OffsetOrientation(yrel * delta, 0.0f);
    }
}

void CAppMain::OnMouseWheel(int y)
{
    if (m_uiDisplay.IsAnyItemActive())
        return;

    float movementDelta = 500.0f * m_lastDeltaTime;
    if (y == -1)
    {
        movementDelta = -movementDelta;
    }
    m_camera.OffsetPosition(movementDelta * m_camera.ForwardVector());
}

// "meshes/simple.rbmesh"
//uint32_t CAppMain::LoadMesh(CMeshFile& meshFile)
//{
//    // remove if loaded already
//    if (m_meshID != 0)
//    {
//        m_display.DeleteMesh(m_meshID);
//        m_meshID = 0;
//    }
//
//    std::vector<CPoly3D> polyList;
//    meshFile.GetAsPolyList(polyList);
//
//    m_polyMesh.Clear();
//    m_polyMesh.AddPolyList(polyList);
//
//    // load any current lightmaps in the file (if any)
//    m_polyMesh.LoadLightmaps(m_display.GetMaterialMgr(), meshFile.GetLightMaps());
//    //mesh.LoadMaterials(m_display.GetMaterialMgr());
//
//    // add this to the renderer
//    m_meshID = m_display.AddMesh(m_polyMesh);
//    return m_meshID;
//}

uint32_t CAppMain::UploadNewMesh(CPolyMesh& polyMesh, std::vector<CLightmapImg>& lightmaps)
{
    // remove if loaded already
    if (m_meshID != 0)
    {
        m_display.DeleteMesh(m_meshID);
        m_meshID = 0;
    }

    // load any current lightmaps in the file (if any)
    polyMesh.LoadLightmaps(m_display.GetMaterialMgr(), lightmaps);
    //mesh.LoadMaterials(m_display.GetMaterialMgr());

    // add this to the renderer
    m_meshID = m_display.AddMesh(m_polyMesh);
    return m_meshID;
}

//// "meshes/simple.rbmesh"
//uint32_t CAppMain::LoadMesh(const std::string& meshFile)
//{
//    if (m_meshID != 0)
//    {
//        m_display.DeleteMesh(m_meshID);
//        m_meshID = 0;
//    }
//
//    CMeshFile m_rbMeshFile;
//
//    if (!m_rbMeshFile.LoadFromFile(meshFile))
//    {
//        OS::Abort("Mesh LoadFromFile() failed\n");
//        return 0;
//    }
//
//    std::vector<CPoly3D> polyList;
//    m_rbMeshFile.GetAsPolyList(polyList);
//
//    CPolyMesh mesh;
//    mesh.AddPolyList(polyList);
//    mesh.LoadLightmaps(m_display.GetMaterialMgr(), m_rbMeshFile.GetLightMaps());
//    //mesh.LoadMaterials(m_display.GetMaterialMgr());
//
//    m_meshID = m_display.AddMesh(mesh);
//
//    return m_meshID;
//}

void CAppMain::UpdateTransformViaInputs(float deltaTime)
{
    float moveSpeed = deltaTime * 250.0f; //250 units per second

    using namespace NKeyboardKeys;

    if (m_inputs.IsPressed(KB_KEY_W))
    {
        m_camera.OffsetPosition(moveSpeed * m_camera.ForwardVector());
        //transform.OffsetPosition(moveSpeed * transform.ForwardVector());
    }

    if (m_inputs.IsPressed(KB_KEY_S))
    {
        m_camera.OffsetPosition(moveSpeed * -m_camera.ForwardVector());
        //transform.OffsetPosition(moveSpeed * -transform.ForwardVector());
    }

    if (m_inputs.IsPressed(KB_KEY_A))
    {
        m_camera.OffsetPosition(moveSpeed * -m_camera.RightVector());
        //transform.OffsetPosition(moveSpeed * -transform.RightVector());
    }

    if (m_inputs.IsPressed(KB_KEY_D))
    {
        m_camera.OffsetPosition(moveSpeed * m_camera.RightVector());
        //transform.OffsetPosition(moveSpeed * transform.RightVector());
    }

    if (m_inputs.IsPressed(KB_KEY_X))
    {
        m_camera.OffsetPosition(moveSpeed * glm::vec3(0, 1, 0));
        //transform.OffsetPosition(moveSpeed * glm::vec3(0, 1, 0));
    }

    if (m_inputs.IsPressed(KB_KEY_LEFT))
    {
        m_camera.OffsetOrientation(0.0f, -70.0f * deltaTime);
        //transform.OffsetOrientation(0.0f, -70.0f * deltaTime);
    }

    if (m_inputs.IsPressed(KB_KEY_RIGHT))
    {
        m_camera.OffsetOrientation(0.0f, 70.0f * deltaTime);
        //transform.OffsetOrientation(0.0f, 70.0f * deltaTime);
    }

    if (m_inputs.IsPressed(KB_KEY_SPACE))
    {
        m_camera.OffsetPosition(moveSpeed * m_camera.UpVector());
        //transform.OffsetPosition(moveSpeed * transform.UpVector());
    }

    if (m_inputs.IsPressed(KB_KEY_Z))
    {
        m_camera.OffsetPosition(moveSpeed * -m_camera.UpVector());
        //transform.OffsetPosition(moveSpeed * -transform.UpVector());
    }
}

bool CAppMain::ProcessLightmaps(NRadeLamp::lmOptions_t lampOptions, std::vector<CLight> lights)
{
    std::string outFile(OS::ResourcePath("meshes/default.rbmesh"));

    // scale light colour values to RGB 0-255 instead of 0-1
    for (auto& light : lights)
    {
        for (float& i : light.color)
            i = std::min<float>(i * 255, 255);
    }

    // delete any exisitng lightmaps generated by this tool
    for (CLightmapImg& lm : m_lightMapList)
    {
        lm.Free();
    }
    m_lightMapList.clear();

    CLightmapGen lmGen;

    OS::Log("generating lightmap data..\n");
    CTimer timer;

    lmGen.RegisterCallback(
            [this](int pctComplete)
            {
                m_uiDisplay.SetPercentComplete(pctComplete, false);
            });

    lmGen.GenerateLightmaps(lampOptions, m_polyMesh.GetPolyListRef(), lights, &m_lightMapList);

    float elapsedTime = timer.ElapsedTime();
    OS::Log("lightmap generation took %.2f seconds\n", elapsedTime);

    // notify of completion (mesh is now written to file)
    m_uiDisplay.SetPercentComplete(100, true);
    return true;
}

bool CAppMain::OnUIMeshLoad(const std::string& filename)
{
    CMeshFile tmpMesh;
    if(tmpMesh.LoadFromFile(filename))
    {
        std::vector<CPoly3D> polyList;
        tmpMesh.GetAsPolyList(polyList);
        m_polyMesh.Clear();
        m_polyMesh.AddPolyList(polyList);

        // delete any existing lightmaps generated by this tool
        for (CLightmapImg& lm : m_lightMapList)
        {
            lm.Free();
        }
        m_lightMapList.clear();

        tmpMesh.GetLightMaps(m_lightMapList);
        m_polyMesh.LoadLightmaps(m_display.GetMaterialMgr(), m_lightMapList);

        m_meshID = UploadNewMesh(m_polyMesh, m_lightMapList);

        return m_meshID>0;
    }
    else
    {
        OS::Log("Cant find mesh %s\n", filename.c_str());
        return false;
    }
}

void CAppMain::OnUILightmapsComplete()
{
    // m_polyMesh is ready
    // m_lightMapList is ready
    // UI system is ready

    m_polyMesh.ClearLightmaps();

    UploadNewMesh(m_polyMesh, m_lightMapList);
}

bool CAppMain::OnUIMeshSave(const std::string& filename)
{
    OS::Log("storing compressed lightmap data in meshfile..\n");
    CMeshFile outputMeshFile(m_polyMesh.GetPolyListRef());

    for (CLightmapImg& lm : m_lightMapList)
    {
        // add these in the same order as generated so indexes match up
        outputMeshFile.AddLightmapData(lm.m_width, lm.m_height, lm.m_data, lm.m_width * lm.m_height * 4);
    }

    if(!outputMeshFile.WriteToFile(filename))
    {
        OS::Log("Failed to save %s\n", filename.c_str());
        return false;
    }

    // Keep if we save again
//    // these have been saved to disk, also the uplaoded lms are on the display now
//    for (CLightmapImg& lm : m_lightMapList)
//    {
//        lm.Free();
//    }
//    m_lightMapList.clear();

    return true;
}
